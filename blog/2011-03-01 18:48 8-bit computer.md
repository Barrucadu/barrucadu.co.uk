Over the past week or so I've been designing a simple 8-bit computer on paper and have recently implemented an assembler and emulator for it, so I've decided to share it with the world. It's not yet finished, as I haven't designed the memory (though I know what I'm going to design, so it's implemented in the emulator). It's a simple little thing with only 14 instructions, 2 (programmer-accessible) registers, and no support for indirect addressing (which is a pain).

Instructions are a byte wide, the lower four bits of which are the opcode, and the upper 4 bits of which are the operand. The address and data buses are eight bits wide, and so memory access is performed using offsets, with an instruction to adjust the base offset. This makes programs particularly susceptible to label-related fails, as a label is assembled to an offset from the start of the segment it is in. Below is a program to calculate fibonacci numbers and save them to memory location 0xFF (which will be an output location in the final design) until an overflow occurs:

            ;; Calculate all fibonacci values that will fit in 8 bits (ie: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233)
            ;; and write them to the output location.
            ;; This code assumes that output is written to 0xFF (which it will be, in the final design).
    
    start:  setmdev tmp             ; Write first fib number (saved in tmp/one) to output
            load one                ;
            setmdev outh            ;
            save    outl            ;
    
    fib:    setmdev tmp             ; Write to the output location
            load one                ;
            setmdev outh            ;
            save    outl            ;
    
            setmdev tmp             ; Calculate the next fib value, and if there was an overflow terminate
            load    one             ;
            sum                     ;
            save    two             ;
            load    one             ;
            copya                   ;
            load    two             ;
            jc      end             ; Carry is set if an addition of A and B *as the previous instruction* would cause a carry (regardless
                                    ; of if the previous instruction was a sum). Thus, merely by having the values
                                    ; in the registers, we can see if we've reached the end of our computation

            save    one             ; Save values to the temporary location
    
            setmdev 0x0             ; Calculate the next
            jmp fib                 ;
            
    end:    setmdev outh            ; Print final output
            save    outl            ;
            
    trap:   setmdev 0x1             ; Halt
            jmp trap                ;
    
    one:    DATA[0x01]              ; Temporary location 1
    two:    DATA[0x00]              ; Temporary location 2
            
            CONSTANT[tmp,0x1]
            CONSTANT[outh,0xF]
            CONSTANT[outl,0xF]

And here is the assembled version of that (in hex):

    10 71 F0 F2 10 71 F0 F2 10 71 07 82 71 03 81 3C 72 00 4D F0 F2 10 5D 01 00

Not bad.

The documentation for the CPU, ALU, and memory currently resides in a [org file](https://github.com/Barrucadu/8-bit-CPU/blob/master/doc/cpu.org) in [this git repository](https://github.com/Barrucadu/8-bit-CPU). There is a rather nice emulator which presents an ncurses interface so you can run programs you build with the supplied assembler. Here is a screenshot of [the emulator running the above program](http://misc.barrucadu.co.uk/emulator.png).

All I have left to design (down to the level of logic gates) is the memory, and I already have a high-level view of how that will function. After that, I might start a second, improved, design. I've learnt a lot about implementing computers since I started this, and want to put this new knowledge to good use.

Also, there is the possibility of a compiler for some high level language in the future, as keeping track of memory offsets by hand and not having any indirect addressing is frustrating.
